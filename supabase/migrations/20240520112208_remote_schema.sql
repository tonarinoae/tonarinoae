drop function if exists "public"."emit_watch_history"(_user_id uuid, _hentai_id bigint);

drop function if exists "public"."save_watch_progress"(_hentai_id bigint, _cur integer, _dur integer);

create table "public"."profiles" (
    "id" uuid not null,
    "first_name" text not null default ''::text,
    "last_name" text not null default 'anonymous'::text
);


alter table "public"."profiles" enable row level security;

alter table "public"."hentai_meta" alter column "id" add generated by default as identity;

alter table "public"."hentai_meta" enable row level security;

alter table "public"."watch_history" enable row level security;

alter table "public"."watch_progress" alter column "cur" drop default;

alter table "public"."watch_progress" alter column "cur" set data type real using "cur"::real;

alter table "public"."watch_progress" alter column "dur" set data type real using "dur"::real;

alter table "public"."watch_progress" enable row level security;

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ begin
insert into public.profiles (id, first_name, last_name)
values (
        new.id,
        new.raw_user_meta_data->>'first_name',
        new.raw_user_meta_data->>'last_name'
    );
return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.save_watch_progress(_hentai_id bigint, _cur double precision, _dur double precision)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    existing_record_count int;
BEGIN
    IF _cur > _dur THEN
        RAISE EXCEPTION 'cur phải nhỏ hơn hoặc bằng dur';
    END IF;

    -- Kiểm tra xem đã có bản ghi trong bảng watch_progress cho user_id và hentai_id chưa
    SELECT COUNT(*)
    INTO existing_record_count
    FROM watch_progress
    WHERE user_id =  auth.uid()
    AND hentai_id = _hentai_id;
    
    -- Nếu đã có bản ghi, cập nhật
    IF existing_record_count > 0 THEN
        UPDATE watch_progress
        SET cur = _cur,
            dur = _dur,
            finished_at = CASE WHEN _cur = _dur THEN CURRENT_TIMESTAMP ELSE NULL END
        WHERE user_id =  auth.uid()
        AND hentai_id = _hentai_id;
    ELSE
        -- Nếu chưa có bản ghi, thêm mới
        INSERT INTO watch_progress (user_id, hentai_id, cur, dur, finished_at)
        VALUES ( auth.uid(), _hentai_id, _cur, _dur, CASE WHEN _cur = _dur THEN CURRENT_TIMESTAMP ELSE NULL END);
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_hentai_meta(_raw_id bigint, _title text, _slug text, _synopsis text, _alternative_titles text[], _thumbnail text, _poster text, _notes text, _censorship text, _category text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO hentai_meta (raw_id, title, slug, synopsis, alternative_titles, thumbnail, poster, notes, censorship, category)
    VALUES (_raw_id, _title, _slug, _synopsis, _alternative_titles, _thumbnail, _poster, _notes, _censorship, _category)
    ON CONFLICT (slug) DO UPDATE
    SET title = EXCLUDED.title,
        synopsis = EXCLUDED.synopsis,
        alternative_titles = EXCLUDED.alternative_titles,
        thumbnail = EXCLUDED.thumbnail,
        poster = EXCLUDED.poster,
        notes = EXCLUDED.notes,
        censorship = EXCLUDED.censorship,
        category = EXCLUDED.category;
END;
$function$
;

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

create policy "Enable insert for authenticated users only"
on "public"."hentai_meta"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read for authenticated users only"
on "public"."hentai_meta"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for authenticated users only"
on "public"."hentai_meta"
as permissive
for update
to authenticated
using (true);


create policy "Enable insert for only user"
on "public"."profiles"
as permissive
for insert
to authenticated
with check ((auth.uid() = id));


create policy "Enable read access for all users"
on "public"."profiles"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "Enable update for users based on email"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "Enable insert for authenticated users only"
on "public"."watch_history"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable read access for only user creator"
on "public"."watch_history"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "Enable update for only user creator"
on "public"."watch_history"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable insert for authenticated users only"
on "public"."watch_progress"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable read access only user"
on "public"."watch_progress"
as permissive
for select
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable update for only user"
on "public"."watch_progress"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = user_id));



